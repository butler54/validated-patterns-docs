---
menu:
  learn:
    parent: Validated patterns frameworks
title: Ansible GitOps Framework 
weight: 23
aliases: /ocp-framework/agof/
---

:toc:
:imagesdir: /images
:_content-type: ASSEMBLY
include::modules/comm-attributes.adoc[]

== About the Ansible GitOps framework (AGOF)for validated patterns

The link:/patterns/ansible-gitops-framework/[Ansible GitOps Framework] provides an extensible framework to do GitOps with https://docs.ansible.com/platform.html[Ansible Automation Platform] (AAP), and as such provides useful facilities for developing patterns (community and validated) that function with Ansible Automation Platform as the GitOps engine.

When there is no access to OpenShift Container Platform, AGOF provides a standalone solution for deploying and managing validated patterns. This framework leverages GitOps principles without relying on OpenShift.

Administrators can use Ansible Automation Platform includes automation controller, a web-based UI interface to define, operate, scale, and delegate automation across their enterprise.

The repository at https://github.com/validatedpatterns/agof/[Ansible GitOps Framework] provides code for installing VMs on AWS, if needed. It can also be used with existing VMs or a functional AAP Controller endpoint. 

The link:https://github.com/validatedpatterns/agof/[Ansible GitOps Framework] repository contains code to set up the infrastructure for applying `controller_configuration` to an AAP instance. It includes some predefined configurations and practices to make the infrastructure as code repository more user-friendly and standardized. An AGOF pattern for example link:https://github.com/mhjacks/agof_demo_config[demo] is primarily an IaC infrastructure as code (IaC) artifact designed to be used with the `controller_configuration` collection.  

== Role of the Ansible Controller

In the Ansible GitOps framework, an ansible controller refers to any machine that initiates and runs a playbook. This includes systems running ansible core or open source Ansible, where the machine executing the playbooks also acts as the controller. AAP provides the automation controller which is Red Hat's productized ansible controller. 

THe link:https://docs.ansible.com/platform.html[Automation controller] is the command and control center for Red Hat Ansible Automation Platform, replacing Ansible Tower. It includes a webUI, API, role-based access control (RBAC), a workflow visualizer, and continuous integration and continuous delivery (CI/CD) integrations to help you organize and manage automation across your enterprise.

The Automation Controller serves as the centralized platform for managing and executing automation across infrastructure. It allows users to create job templates that standardize the deployment and execution of Ansible playbooks, making automation more consistent and reusable. It integrates essential components such as execution environments for consistent automation execution, projects (repositories for automation content), inventories (target endpoints), and credentials (for secure access to resources).

The webUI provides an intuitive interface to build, monitor, and manage automation workflows, while the API offers seamless integration with other tools, such as CI/CD pipelines or orchestration platforms. Overall, the Automation Controller streamlines the automation lifecycle, ensuring a scalable, secure, and maintainable automation environment.

== Ansible framework methods

The three main methods for setting up an Ansible framework in relation to Ansible Automation Platform (AAP) 2.4 can be summarized as follows:

=== Method 1: AWS-based install

This method is ideal for organizations that prefer deploying AAP on AWS infrastructure. This default install process in AAP 2.4 uses AWS by default and offers a fully automated setup. It requires AWS credentials, builds an AWS image with Red Hat's ImageBuilder, and sets up AAP within an AWS VPC and subnet. The installation program creates all the necessary resources, including AAP Controllers and, optionally, additional components such as Automation Hub.

*Pros*: This is the easiest method if you already use AWS, as it automates the provisioning of resources, including VMs and network configurations.  

*Cons*: This requires AWS infrastructure and credentials. This is not ideal if you're working in an on-premises environment or a cloud platform other than AWS.

=== Method 2: Pre-configured VMs Install

This method allows the installation of AAP on pre-configured Red Hat Enterprise Linux (RHEL) VMs. It requires you to provide an inventory file that specifies details about the VMs or instances where AAP will be installed. It is designed for users with existing infrastructure who want to deploy AAP without depending on AWS. If you need to install a pattern on a cluster with a different topology than this, use the API install mechanism.

*Pros*: Useful if you already have pre-configured VMs or bare-metal instances running RHEL. It allows greater flexibility and control over the environment.  

*Cons*: Requires more manual effort to configure VMs and may need additional customization for non-standard topologies. 

This model has been tested with up to two RHEL VMs (one for AAP and one for Hub).

The requirements for this mode are as follows:

* Must be running a version of RHEL that AAP supports
* Must be properly entitled with a subscription that makes the appropriate AAP repository available

=== Method 3: Custom Ansible controller (API install aka "Bare")

In this method, you provide an existing Ansible Automation Platform (AAP) Controller endpoint, either on bare metal or in a private cloud, without needing AWS or pre-configured VMs. You specify the manifest, endpoint hostname, admin credentials, and pass the installation process to a predefined `controller_config_dir`. This is suitable for complex or custom topologies where you want full control over the deployment.

*Pros*: Provides maximum flexibility and is designed for advanced users who have their own AAP installations, either on-prem or in complex environments that do not fit into the default or AWS-centric model.  

*Cons*: Requires an existing AAP controller, which might not be ideal for users new to AAP or those looking for more hands-off installation

== Creating a validated pattern using the AGOF framework

Whichever method you use to deploy a validated pattern you need to:

. Clone the link:https://github.com/mhjacks/agof_demo_config[Ansible GitOps Framework Minimal Demo] repository. This is a minimal pattern that demonstrates how to use the Ansible GitOps Framework.
+
[source,terminal]
----
$ git clone https://github.com/validatedpatterns-demos/agof_minimal_demo.git
----

. Clone the link:https://github.com/validatedpatterns/agof[AGOF] repository. This serves as the provisioner for the pattern
+
[source,terminal]
----
$ git clone https://github.com/validatedpatterns-demos/agof_minimal_demo.git
----

=== Deploying using the AWS-based install method

This method: 

. Builds an AWS image using Red Hat's ImageBuilder.

. Deploys that image onto a new AWS VPC and subnet.

. Deploys AAP on that image using the command line installer. 

. Hands over the configuration of the AAP installation to the specified `controller_config_dir`. 

.Prerequisites

You need to provide some key information to a file named `agof_vault.yml` created in your home directory. The key pieces of information needed are: 

* The name of a hosted zone created under Route 53 in AWS. For example this could be `aws.validatedpatterns.io`.

* Your AWS account `Account ID`

* Your `aws key`

* Your `secret access key`

.Procedure

. Copy the `agof_vault_template.yml` from the cloned `agof` directory to your home directory and rename it `agof_vault.yml`. 
+
[source,terminal]
----
$ cp ~/agof/agof_vault_template.yml ~/agof_vault.yml
----
+

. Agof vault settings

[cols="30%,70%", options="header"]
|===
| Argument | Description

| `aws_account_nbr_vault`
| Your AWS account number. This is needed for sharing composer images.

| `aws_access_key_vault`
| Your AWS access key.

| `aws_secret_key_vault`
| Your AWS secret key.

| `pattern_prefix`
| A unique prefix to distinguish instances in AWS. Used as the pattern name and in public DNS entries.

| `ec2_region`
| An AWS region that your account has access to.

| `offline_token`
| A Red Hat offline token used to build the RHEL image on https://console.redhat.com[console.redhat.com].

[NOTE]
====
Click the `GENERATE TOKEN` link at https://access.redhat.com/management/api[Red Hat API Tokens] to create the token. 
====

| `redhat_username`
| Red Hat Subscription username, used to log in to https://registry.redhat.io[registry.redhat.io].

| `redhat_password`
| Red Hat Subscription password, used to log in to https://registry.redhat.io[registry.redhat.io].

| `admin_password`
| An admin password for AAP Controller and Automation Hub.

| `manifest_content`
| Content for a manifest file to entitle AAP Controller. See below for an example of how to point to a local file.

| `org_number_vault`
| The Organization Number (Org ID) attached to your Red Hat Subscription for RHEL and AAP.

| `activation_key_vault`
| The name of an Activation Key to embed in the imagebuilder image.

[NOTE]
====
Click the `Create Activation Keys` link at https://console.redhat.com[console.redhat.com] > *Red Hat Enterprise Linux* > *Inventory* > *System Configuration* > *Activation Keys* to create an activation key. 
====

| `skip_imagebuilder_build`
| Set these variables to provide your own AMI, or to re-use an AMI previously generated with this process. When a previously built AMI is found this check does not take place. 
#imagebuilder_ami: 'The ID of an AWS AMI image, preferably one that was built with this toolkit'

| `automation_hub_token_vault`
| A token associated with your AAP subscription used to retrieve Automation Hub content.

[NOTE]
====
Click the `Load token` link at https://console.redhat.com[console.redhat.com] > *Ansible Automation Platform* > *Automation Hub* > *Connect to Hub* to generate a token. 
====

| `automation_hub_url_certified_vault`
| Optional: The private automation hub URL for certified content.

| `automation_hub_url_validated_vault`
| Optional: The private automation hub URL for validated content.
|===



. Edit the file and add the following:

* `controller_config_dir:` set it's value to `{{ '~/agof_minimal_demo/config' | expanduser }}`.
* `db_password:` set an appropriate value for the postgres password for the DB instance for example `test`. 
* `agof_statedir:` set its value to "{{ '~/agof' | expanduser }}"
* `agof_iac_repo:` set its value to "https://github.com/mhjacks/agof_demo_config.git"

. Optional: Create a subscription manifest by following the guidance at link:https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.4/htmlred_hat_ansible_automation_platform_operations_guide/assembly-aap-obtain-manifest-files#assembly-aap-obtain-manifest-files[Obtaining a manifest file]

.. Update your `agof_vault.yml` file with the path to downloaded manifest zip file. For example add the following: 
+
[source,shell]
----
controller_license_src_file: '~/Downloads/manifest_<sub_allocation_name>_20240924T131518Z.zip'
manifest_content: "{{ lookup('file', controller_license_src_file) | b64encode }}"
----

.Example agof_vault.yml file

[source,yaml]
----
---
aws_account_nbr_vault: '293265215425'
aws_access_key_vault: 'AKIAIJ6ZIKPAUZGF2643'
aws_secret_key_vault: 'gMC3Jy3/MZtOosjUDHy0Nl/2mp2HQok1JDfCQGKUR'

pattern_prefix: 'foga'
pattern_dns_zone: 'aws.validatedpatterns.io'

ec2_name_prefix: 'foga-testing'
ec2_region: 'us-east-1'

offline_token: '<insert-token-here>'

redhat_username: 'rhn-support-myusername'
redhat_password: 'passwd01'

admin_password: 'redhat123!'

manifest_content: "Content for a manifest file to entitle AAP Controller. See below for an example of how to point to a local file"
#manifest_content: "{{ lookup('file', '~/Downloads/manifest_AVP_20230510T202608Z.zip') | b64encode }}"

org_number_vault: "1778713"
activation_key_vault: "kevs-agof-key"

# Set these variables to provide your own AMI, or to re-use an AMI previously generated with this process
#skip_imagebuilder_build: 'boolean: skips imagebuilder build process'
#imagebuilder_ami: 'The ID of an AWS AMI image, preferably one that was built with this toolkit'

automation_hub_token_vault: '<insert-token-here>'

# These variables can be set but are optional. The previous (before AAP 2.4) conncept of sync-list was private
# to an account.
#automation_hub_url_certified_vault: 'The private automation hub URL for certified content'
#automation_hub_url_validated_vault: 'The private automation hub URL for validated content'

controller_config_dir: "{{ '~/agof_minimal_demo/config' | expanduser }}"

db_password: 'test'

agof_statedir: "{{ '~/agof' | expanduser }}"
agof_iac_repo: "https://github.com/mhjacks/agof_demo_config.git"
----

. Run from the AGOF repository directory the following command : 
+
[source,terminal]
----
$ ./pattern.sh make install
----
This command invokes the `controller_configuration` `dispatch` role on the controller endpoint based on the configuration found in the `controller_configuration_dir` and in your `agof_vault.yml` file. This controls all of the controller configuration. Based on the variables defined in the controller configuration, `dispatch` calls the necessary roles and modules in the right order to configure AAP to run your pattern.

.Verification

The default installation provides an AAP 2.4 installation deployed using the containerized installer, with services deployed this way:

.agof_vault settings
[cols="30%,70%",options="header"]
|===
| URL | Service

| `https:{{ ec2_name_prefix }}.{{ domain }}:8443`
a| Controller API. 

| `https:{{ ec2_name_prefix }}.{{ domain }}:8444/` 
a|Private Automation Hub

| `https:/{{ ec2_name_prefix }}.{{ domain }}:8445/``
a| EDA Automation Controller

|===

Once the install completes, you will have a project, an inventory (consisting of the AAP controller), a credential (the private key from ec2), a job template (which runs a fact gather on the AAP controller) and a schedule that will run the job template every 5 minutes,

. Log in to `https:{{ ec2_name_prefix }}.{{ domain }}:8443` with the username `admin` and the password as configured in `admin_password` field of `agof_vault.yml`. 

. Under *Resources* > *Projects* verify the project *Ansible GitOps Framework Minimal Demo* is created with status *Successful*.

. Under *Resources* > *Inventories* verify the inventory *AGOF Demo Inventory* is created with sync status *Success*.

. Under *Resources* > *Templates* verify the job template *Ping Playbook* is created.

. Under *Resources* > *Credentials* verify the ec2 ssh credential *ec2_ssh_credential* is created.

. Under *Views* > *Schedules* verify the schedules are created.


=== Method 2: Pre-configured VMs Install

This method allows the installation of AAP on pre-configured Red Hat Enterprise Linux (RHEL) VMs. It requires you to provide an inventory file that specifies details about the VMs or instances where AAP will be installed. 

It is designed for users with existing infrastructure who want to deploy AAP without depending on AWS. If you need to install a pattern on a cluster with a different topology than this, use the API install mechanism.

[source,shell]
----
./pattern.sh make legacy_from_os_install INVENTORY=(your_inventory_file)
----

The path to `your_inventory_file` defaults to ~/inventory_agof if you do not specify one.

.Example agof_inventory file

[source,yaml]
----
[build_control]
localhost

[aap_controllers]
192.168.5.207

[automation_hub]

[eda_controllers]

[aap_controllers:vars]

[automation_hub:vars]

[all:vars]
ansible_user=myuser
ansible_ssh_pass=mypass
ansible_become_pass=mypass
ansible_remote_tmp=/tmp/.ansible
username=myuser
controller_hostname=192.168.5.207
----

=== Method 3: Custom Ansible controller (API install)

In this method, you provide an existing Ansible Automation Platform (AAP) Controller endpoint, either on bare metal or in a private cloud, without needing AWS or pre-configured VMs. 

Specify 

manifest
endpoint hostname
admin credentials, and pass the installation process to a predefined `controller_config_dir`. 


[source,terminal]
----
./pattern.sh make api_install
----

=== Tearing down the installation 

To tear down the installation run the following command:

[source,terminal]
----
$ ./pattern.sh make aws_uninstall
----